{% extends "base.html" %} {% block title %}AI í•™ìŠµ ë„êµ¬ - ì˜¤ëˆ„ì´ í•œêµ­ì–´{%
endblock %} {% block content %}
<div class="max-w-4xl mx-auto px-4">
  <style>
    /* Tweak vertical rhythm for learning page content */
    /* Dialogue text: slightly tighter but readable */
    #contentResult .dialogue-text {
      line-height: 1.45;
    }

    /* Speaker/name and small helper text */
    #contentResult .dialogue-item p {
      line-height: 1.25;
    }

    /* Pronunciation line (italic small text) */
    #contentResult .pronunciation-text {
      line-height: 1.2;
      display: inline-block;
    }

    /* Model test result (prose) â€” make paragraphs a bit more airy */
    #modelTestResult,
    #modelTestResult p {
      line-height: 1.6;
    }

    /* Vocabulary tag labels should be compact */
    #contentResult .rounded-full {
      line-height: 1.15;
    }

    /* Small screens: slightly tighter to save space */
    @media (max-width: 640px) {
      #contentResult .dialogue-text {
        line-height: 1.35;
      }
      #modelTestResult,
      #modelTestResult p {
        line-height: 1.45;
      }
    }
  </style>
  <div class="bg-white rounded-2xl p-6 shadow-lg">
    <!-- Header -->
    <header class="mb-6">
      <div
        class="inline-flex items-center gap-2 px-3 py-1 bg-blue-100 text-blue-800 rounded-full text-xs font-semibold mb-2"
      >
        <span class="w-2 h-2 bg-blue-500 rounded-full"></span>
        ONUI Â· AI í•™ìŠµ ë„êµ¬
      </div>
      <h1 class="text-3xl font-bold text-gray-900 mb-2">
        <img
          src="https://twemoji.maxcdn.com/v/latest/svg/1f1f0-1f1f7.svg"
          alt="ğŸ‡°ğŸ‡·"
          class="inline-block w-6 h-6 mr-2 align-middle"
        />ì˜¤ëˆ„ì´ AI í•™ìŠµ í”Œë«í¼
      </h1>
      <p class="text-sm text-gray-600">AIë¥¼ í™œìš©í•œ ë§ì¶¤í˜• í•œêµ­ì–´ í•™ìŠµ ê²½í—˜</p>
    </header>

    <!-- 1. Content Generation Section -->
    <section
      class="mb-6 p-4 bg-gradient-to-br from-blue-50 to-indigo-50 rounded-xl border border-blue-200"
    >
      <div class="flex items-center justify-between mb-3">
        <h2 class="text-lg font-semibold text-gray-900 flex items-center gap-2">
          <span class="text-2xl">ğŸ“š</span>
          1. ë§ì¶¤í˜• êµì¬ ìƒì„±
        </h2>
        <a
          href="/content-generation"
          class="text-sm px-3 py-1 bg-blue-500 text-white rounded-full hover:bg-blue-600 transition"
        >
          ì „ì²´ ë³´ê¸° â†’
        </a>
      </div>

      <div
        class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-2 mb-3"
      >
        <input
          id="topic"
          type="text"
          placeholder="ê´€ì‹¬ ì£¼ì œ (ì˜ˆ: ê¹€ì¹˜)"
          value="ê¹€ì¹˜"
          class="border border-gray-300 p-2 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-sm lg:col-span-2"
          onkeydown="if (event.key === 'Enter') { event.preventDefault(); if (document.getElementById('topic').value.trim()) generateContent(); }"
        />
        <select
          id="level"
          class="border border-gray-300 p-2 rounded-lg focus:ring-2 focus:ring-blue-500 text-sm lg:col-span-1"
        >
          <option value="ì´ˆê¸‰">ì´ˆê¸‰</option>
          <option value="ì¤‘ê¸‰" selected>ì¤‘ê¸‰</option>
          <option value="ê³ ê¸‰">ê³ ê¸‰</option>
        </select>
        <select
          id="modelSelect"
          class="border border-gray-300 p-2 rounded-lg focus:ring-2 focus:ring-blue-500 text-sm lg:col-span-1"
        >
          <option value="exaone3.5:2.4b" data-backend="ollama" selected>
            EXAONE 3.5
          </option>
          <option value="gemini-2.5-flash" data-backend="gemini">
            Gemini Flash
          </option>
        </select>
        <button
          id="generateBtn"
          onclick="toggleGeneration()"
          class="bg-gradient-to-r from-blue-500 to-indigo-600 text-white px-4 py-2 rounded-lg transition-all shadow-md text-sm font-medium lg:col-span-1"
        >
          ğŸª„ ìƒì„±í•˜ê¸°
        </button>
      </div>

      <div
        id="contentResult"
        class="bg-white p-4 rounded-lg shadow-sm hidden border border-gray-200"
      ></div>

      <!-- Model Test Section -->
      <div class="mt-4 pt-4 border-t border-blue-200">
        <label class="text-xs font-semibold text-gray-700 mb-2 block"
          >ğŸ’¬ AIì™€ ëŒ€í™”í•´ë³´ê¸°</label
        >
        <div class="grid grid-cols-6 gap-2">
          <input
            id="testPrompt"
            type="text"
            class="col-span-5 border border-gray-300 p-2 rounded-lg focus:ring-2 focus:ring-blue-500 text-sm"
            placeholder="AIì—ê²Œ ë¬¼ì–´ë³´ê³  ì‹¶ì€ ê²ƒì„ ììœ ë¡­ê²Œ ì…ë ¥í•´ ë³´ì„¸ìš” ğŸ˜Š"
            onkeydown="if (event.key === 'Enter') { event.preventDefault(); testModel(); }"
          />
          <button
            onclick="testModel()"
            class="col-span-1 bg-indigo-500 text-white px-4 py-2 rounded-lg hover:bg-indigo-600 transition-colors text-sm"
          >
            âœ¨ ë¬¼ì–´ë³´ê¸°
          </button>
        </div>
        <div
          id="modelTestResult"
          class="mt-2 p-3 bg-gray-50 rounded-lg text-sm hidden prose max-w-full border border-gray-200"
        ></div>
      </div>
    </section>

    <!-- 2. Essay Test Section -->
    <section
      class="mb-6 p-4 bg-gradient-to-br from-green-50 to-emerald-50 rounded-xl border border-green-200"
    >
      <div class="flex items-center justify-between mb-3">
        <h2 class="text-lg font-semibold text-gray-900 flex items-center gap-2">
          <span class="text-2xl">âœï¸</span>
          2. í•œêµ­ì–´ ì‘ë¬¸ í…ŒìŠ¤íŠ¸
        </h2>
        <a
          href="/essay-test"
          class="text-sm px-3 py-1 bg-green-500 text-white rounded-full hover:bg-green-600 transition"
        >
          ì „ì²´ ë³´ê¸° â†’
        </a>
      </div>

      <div class="bg-white p-4 rounded-lg shadow-sm">
        <textarea
          id="fluencyInput"
          placeholder="ì˜¤ëŠ˜ ê¸°ë¶„ì´ ì–´ë–¤ì§€ í•œêµ­ì–´ë¡œ ì¨ë³´ì„¸ìš”..."
          class="w-full border border-gray-300 p-3 rounded-lg mb-3 h-24 focus:ring-2 focus:ring-green-500 focus:border-transparent resize-none text-sm"
        ></textarea>

        <button
          onclick="checkFluency()"
          class="w-full bg-gradient-to-r from-green-500 to-emerald-600 text-white px-4 py-3 rounded-lg hover:from-green-600 hover:to-emerald-700 transition-all shadow-md hover:shadow-lg font-medium"
        >
          ì œì¶œ ë° ì±„ì 
        </button>

        <div
          id="fluencyResult"
          class="mt-3 p-4 rounded-lg bg-white hidden border border-gray-200 shadow-sm"
        ></div>
      </div>
    </section>

    <!-- 3. Situational Content Section -->
    <section
      class="mb-6 p-4 bg-gradient-to-br from-purple-50 to-pink-50 rounded-xl border border-purple-200"
    >
      <div class="flex items-center justify-between mb-3">
        <h2 class="text-lg font-semibold text-gray-900 flex items-center gap-2">
          <span class="text-2xl">ğŸ­</span>
          3. ìƒí™©ë³„ ì»¨í…ì¸  ìƒì„±
        </h2>
        <a
          href="/media-generation"
          class="text-sm px-3 py-1 bg-purple-500 text-white rounded-full hover:bg-purple-600 transition"
        >
          ì „ì²´ ë³´ê¸° â†’
        </a>
      </div>

      <div class="bg-white p-4 rounded-lg shadow-sm">
        <div class="grid grid-cols-1 sm:grid-cols-2 gap-2 mb-3">
          <select
            id="situation"
            class="border border-gray-300 p-2 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent text-sm"
          >
            <option value="">ìƒí™©ì„ ì„ íƒí•´ì£¼ì„¸ìš”</option>
            <option value="ì¹´í˜">â˜• ì¹´í˜ì—ì„œ ì£¼ë¬¸í•˜ê¸°</option>
            <option value="ì‹ë‹¹">ğŸ½ï¸ ì‹ë‹¹ì—ì„œ ì˜ˆì•½í•˜ê¸°</option>
            <option value="ë³‘ì›">ğŸ¥ ë³‘ì› ì§„ë£Œ ë°›ê¸°</option>
            <option value="ì€í–‰">ğŸ¦ ì€í–‰ ì—…ë¬´ë³´ê¸°</option>
            <option value="ì—¬í–‰">âœˆï¸ ì—¬í–‰ ê³„íší•˜ê¸°</option>
            <option value="ë©´ì ‘">ğŸ’¼ ë©´ì ‘ ì¤€ë¹„í•˜ê¸°</option>
          </select>
          <select
            id="situationLevel"
            class="border border-gray-300 p-2 rounded-lg focus:ring-2 focus:ring-purple-500 text-sm"
          >
            <option value="ì´ˆê¸‰">ì´ˆê¸‰</option>
            <option value="ì¤‘ê¸‰" selected>ì¤‘ê¸‰</option>
            <option value="ê³ ê¸‰">ê³ ê¸‰</option>
          </select>
        </div>

        <button
          onclick="generateSituationalContent()"
          class="w-full bg-gradient-to-r from-purple-500 to-pink-600 text-white px-4 py-3 rounded-lg hover:from-purple-600 hover:to-pink-700 transition-all shadow-md hover:shadow-lg font-medium"
        >
          ì»¨í…ì¸  ìƒì„±
        </button>

        <div
          id="situationalResult"
          class="mt-3 p-4 rounded-lg bg-white hidden border border-gray-200 shadow-sm"
        ></div>
      </div>
    </section>

    <!-- Tips Section -->
    <section class="p-4 bg-gray-50 rounded-xl border border-gray-200">
      <div class="text-sm font-semibold text-gray-900 mb-2">ğŸ’¡ ì‚¬ìš© íŒ</div>
      <div class="text-xs text-gray-700 space-y-1">
        <p>
          â€¢ <strong>êµì¬ ìƒì„±</strong>: ê´€ì‹¬ ì£¼ì œì™€ ë ˆë²¨ì„ ì„ íƒí•˜ë©´ AIê°€ ë§ì¶¤í˜•
          ëŒ€í™”ë¬¸ê³¼ ë‹¨ì–´ì¥ì„ ìƒì„±í•©ë‹ˆë‹¤
        </p>
        <p>
          â€¢ <strong>ì‘ë¬¸ í…ŒìŠ¤íŠ¸</strong>: ììœ ë¡­ê²Œ í•œêµ­ì–´ë¡œ ì‘ì„±í•˜ë©´ AIê°€ ë¬¸ë²•ê³¼
          ìì—°ìŠ¤ëŸ¬ì›€ì„ í‰ê°€í•©ë‹ˆë‹¤
        </p>
        <p>
          â€¢ <strong>ìƒí™©ë³„ ì»¨í…ì¸ </strong>: ì¼ìƒì—ì„œ ë§ˆì£¼ì¹  ìˆ˜ ìˆëŠ” ë‹¤ì–‘í•œ
          ìƒí™©ì—ì„œì˜ í‘œí˜„ê³¼ ëŒ€í™”ë¥¼ í•™ìŠµí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
        </p>
        <p>
          â€¢ <strong>ë°œìŒ í‰ê°€</strong>: SpeechPro(ë°œìŒ ì •í™•ë„)ì™€
          FluencyPro(ìœ ì°½ì„±)ì—ì„œ ìŒì„± í‰ê°€ë¥¼ ì§„í–‰í•˜ì„¸ìš”
        </p>
        <p>
          â€¢ <strong>ëª¨ë¸ ì„ íƒ</strong>: ë‹¤ì–‘í•œ Ollama ëª¨ë¸ì„ ì„ íƒí•˜ì—¬ ìµœì ì˜
          ê²°ê³¼ë¥¼ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤
        </p>
      </div>
    </section>
  </div>
</div>

<!-- SpeechPro ê²°ê³¼ ëª¨ë‹¬ -->
<div
  id="speechpro-modal"
  class="hidden fixed inset-0 z-50 flex items-center justify-center bg-black/60 p-4"
>
  <div
    class="relative w-full max-w-3xl max-h-[90vh] overflow-y-auto bg-white rounded-2xl shadow-2xl p-8"
  >
    <button
      class="absolute top-3 right-3 text-gray-500 hover:text-gray-800 text-2xl"
      onclick="closeSpeechProModal()"
      aria-label="ë‹«ê¸°"
    >
      âœ•
    </button>

    <h2 class="text-2xl font-bold text-gray-900 mb-6">ğŸ“Š ë°œìŒ í‰ê°€ ê²°ê³¼</h2>

    <!-- ì ìˆ˜ ì¹´ë“œ -->
    <div class="bg-white rounded-2xl shadow p-6 mb-6">
      <!-- ì „ì²´ ì ìˆ˜ -->
      <div class="mb-6">
        <div class="text-center">
          <div class="text-6xl font-bold text-blue-600 mb-2">
            <span id="sp-overall-score">0</span>/100
          </div>
          <p
            id="sp-score-feedback"
            class="text-lg text-gray-600 font-semibold"
          ></p>
        </div>

        <!-- ì ìˆ˜ ê²Œì´ì§€ -->
        <div class="mt-6">
          <div class="w-full bg-gray-200 rounded-full h-4 overflow-hidden">
            <div
              id="sp-score-bar"
              class="bg-gradient-to-r from-red-500 via-yellow-500 to-green-500 h-full transition-all duration-500"
              style="width: 0%"
            ></div>
          </div>
        </div>
      </div>

      <!-- ìƒì„¸ ì •ë³´ -->
      <div class="border-t pt-6">
        <h3 class="text-lg font-semibold text-gray-900 mb-4">ìƒì„¸ ë¶„ì„</h3>
        <div id="sp-details-content" class="space-y-3 text-gray-700">
          <!-- ë™ì ìœ¼ë¡œ ìƒì„±ë¨ -->
        </div>
      </div>
    </div>

    <!-- AI í”¼ë“œë°± ì„¹ì…˜ -->
    <div
      id="sp-ai-feedback-section"
      class="bg-blue-50 border-l-4 border-blue-500 rounded-lg p-6 mb-6 hidden"
    >
      <h3 class="text-lg font-semibold text-blue-900 mb-3">
        ğŸ¤– AI ê°œì„  í”¼ë“œë°±
      </h3>
      <div
        id="sp-ai-feedback-content"
        class="text-blue-800 whitespace-pre-wrap"
      >
        <!-- ë™ì ìœ¼ë¡œ ìƒì„±ë¨ -->
      </div>
    </div>

    <div class="flex justify-end gap-3">
      <button
        onclick="closeSpeechProModal()"
        class="px-6 py-2 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300 transition"
      >
        ë‹«ê¸°
      </button>
    </div>
  </div>
</div>

<script>
  // Load lightweight Markdown rendering (marked) and sanitizer (DOMPurify) via CDN.
  // These are optional; the code falls back to plain text if they are not available.
  (function loadMarkdownLibs() {
    const scripts = [
      { src: "https://cdn.jsdelivr.net/npm/marked/marked.min.js" },
      {
        src: "https://cdn.jsdelivr.net/npm/dompurify@2.4.0/dist/purify.min.js",
      },
    ];
    for (const s of scripts) {
      const scr = document.createElement("script");
      scr.src = s.src;
      scr.async = true;
      document.head.appendChild(scr);
    }
  })();
  // Helper to escape single/double quotes and newlines when injecting into HTML strings
  function jsEsc(s) {
    return (s || "")
      .toString()
      .replace(/\\/g, "\\\\")
      .replace(/'/g, "\\'")
      .replace(/\"/g, '\\"')
      .replace(/\n/g, " ")
      .replace(/\r/g, " ");
  }

  // Generation control
  let abortController = null;
  let isGenerating = false;

  // Toggle generation/stop
  function toggleGeneration() {
    if (isGenerating) {
      stopGeneration();
    } else {
      generateContent();
    }
  }

  // Stop generation
  function stopGeneration() {
    if (abortController) {
      abortController.abort();
      abortController = null;
    }
    isGenerating = false;
    updateGenerateButton();

    const resultDiv = document.getElementById("contentResult");
    resultDiv.innerHTML =
      '<div class="text-sm text-gray-600">ìƒì„±ì´ ì¤‘ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤.</div>';
  }

  // Update button state
  function updateGenerateButtonState(generating) {
    const btn = document.getElementById("generateBtn");
    if (!btn) return;

    isGenerating = generating;

    if (generating) {
      btn.innerHTML = "â¹ï¸ ì¤‘ì§€";
      btn.classList.remove(
        "from-blue-500",
        "to-indigo-600",
        "hover:from-blue-600",
        "hover:to-indigo-700"
      );
      btn.classList.add(
        "from-red-500",
        "to-red-600",
        "hover:from-red-600",
        "hover:to-red-700"
      );
    } else {
      btn.innerHTML = "ğŸª„ ìƒì„±í•˜ê¸°";
      btn.classList.remove(
        "from-red-500",
        "to-red-600",
        "hover:from-red-600",
        "hover:to-red-700"
      );
      btn.classList.add(
        "from-blue-500",
        "to-indigo-600",
        "hover:from-blue-600",
        "hover:to-indigo-700"
      );
    }
  }

  // 1. Content generation
  async function generateContent() {
    console.log("generateContent() called");
    const topic = document.getElementById("topic").value;
    const level = document.getElementById("level").value;
    const resultDiv = document.getElementById("contentResult");

    console.log("Topic:", topic, "Level:", level);

    // Create new abort controller
    abortController = new AbortController();
    updateGenerateButtonState(true);

    // Record start time
    const startTime = performance.now();

    resultDiv.innerHTML =
      '<div class="flex items-center gap-3"><div class="animate-spin rounded-full h-5 w-5 border-b-2 border-blue-600"></div><span class="text-sm text-gray-600">AIê°€ êµì¬ë¥¼ ë§Œë“¤ê³  ìˆìŠµë‹ˆë‹¤...</span></div>';
    resultDiv.classList.remove("hidden");

    const formData = new FormData();
    formData.append("topic", topic);
    formData.append("level", level);

    // Get selected model and its backend
    const modelSelect = document.getElementById("modelSelect");
    const selectedOption = modelSelect.options[modelSelect.selectedIndex];
    const backend = selectedOption.getAttribute("data-backend");
    const model = selectedOption.value;

    console.log("Backend:", backend, "Model:", model);

    if (backend) formData.append("backend", backend);
    if (model) formData.append("model", model);

    try {
      const res = await fetch("/api/generate-content", {
        method: "POST",
        body: formData,
        signal: abortController.signal,
      });

      console.log("Response status:", res.status, res.ok);

      if (!res.ok) {
        throw new Error("Generation failed");
      }

      const data = await res.json();
      console.log("Data received:", data);

      // Calculate elapsed time
      const endTime = performance.now();
      const elapsedSeconds = ((endTime - startTime) / 1000).toFixed(1);

      // Robust JSON extraction: handle cases where the server returns JSON
      // as an object, under `parsed`, or as raw text (possibly fenced).
      let jsonObj = null;

      function tryParseJSONFromString(s) {
        if (!s || typeof s !== "string") return null;
        // Helper to attempt JSON.parse with some pre-cleaning
        function tryParseCandidate(candidate) {
          try {
            return JSON.parse(candidate);
          } catch (e) {
            return null;
          }
        }

        // 1) direct parse
        try {
          const parsed = tryParseCandidate(s);
          if (parsed) return normalizeParsed(parsed);
        } catch (e) {}

        // 2) fenced JSON (```json ... ```)
        try {
          const m = s.match(/```(?:json)?\s*([\s\S]*?)\s*```/i);
          if (m && m[1]) {
            try {
              const parsed = tryParseCandidate(m[1].trim());
              if (parsed) return normalizeParsed(parsed);
            } catch (e) {}
          }
        } catch (e) {}

        // 3) find first {...} that contains both keys
        try {
          const m2 = s.match(/\{[\s\S]*"dialogue"[\s\S]*"vocabulary"[\s\S]*\}/);
          if (m2) {
            try {
              // try to repair single quotes and trailing commas
              let cand = m2[0];
              // naive single-quote -> double-quote replacement for keys/strings
              const repaired = cand
                .replace(/'([^']*)'/g, '"$1"')
                .replace(/,\s*}/g, "}")
                .replace(/,\s*\]/g, "]");
              const parsed =
                tryParseCandidate(repaired) || tryParseCandidate(cand);
              if (parsed) return normalizeParsed(parsed);
            } catch (e) {}
          }
        } catch (e) {}

        // 4) as a last resort, try extracting from first/last brace
        try {
          const first = s.indexOf("{");
          const last = s.lastIndexOf("}");
          if (first >= 0 && last > first) {
            const cand = s.slice(first, last + 1);
            try {
              const repaired = cand
                .replace(/'([^']*)'/g, '"$1"')
                .replace(/,\s*}/g, "}")
                .replace(/,\s*\]/g, "]");
              const parsed =
                tryParseCandidate(repaired) || tryParseCandidate(cand);
              if (parsed) return normalizeParsed(parsed);
            } catch (e) {}
          }
        } catch (e) {}

        return null;
      }

      // Normalize parsed object: map alternative keys (Korean/English variants)
      function normalizeParsed(obj) {
        if (!obj) return null;
        // If obj is an array, treat it as dialogue
        if (Array.isArray(obj)) return { dialogue: obj, vocabulary: [] };

        const result = { dialogue: null, vocabulary: null };

        // dialogue keys candidates
        const dlgKeys = [
          "dialogue",
          "ëŒ€í™”",
          "ëŒ€í™”ë¬¸",
          "dialogs",
          "conversation",
          "utterances",
        ];
        for (const k of dlgKeys) {
          if (Object.prototype.hasOwnProperty.call(obj, k)) {
            result.dialogue = obj[k];
            break;
          }
        }

        // vocabulary keys candidates
        const vocabKeys = ["vocabulary", "ë‹¨ì–´", "ë‹¨ì–´ì¥", "words"];
        for (const k of vocabKeys) {
          if (Object.prototype.hasOwnProperty.call(obj, k)) {
            result.vocabulary = obj[k];
            break;
          }
        }

        // If dialogue not found but object has numeric-indexed items, try to collect them
        if (!result.dialogue) {
          const maybeArr = Object.keys(obj)
            .filter((k) => /^\d+$/.test(k))
            .sort((a, b) => Number(a) - Number(b))
            .map((k) => obj[k]);
          if (maybeArr.length) result.dialogue = maybeArr;
        }

        // If still no dialogue but obj has top-level text that contains a JSON string, try recursively
        if (!result.dialogue && typeof obj === "object") {
          for (const v of Object.values(obj)) {
            if (typeof v === "string") {
              const nested = tryParseJSONFromString(v);
              if (nested && nested.dialogue) return normalizeParsed(nested);
            }
          }
        }

        // Ensure defaults
        if (!result.dialogue) return null;
        if (!result.vocabulary) result.vocabulary = [];

        return result;
      }

      if (data && typeof data === "object") {
        if (data.dialogue && data.vocabulary) jsonObj = data;
        else if (data.parsed && data.parsed.dialogue) jsonObj = data.parsed;
        else if (data.text && typeof data.text === "string")
          jsonObj = tryParseJSONFromString(data.text);
      } else if (typeof data === "string") {
        jsonObj = tryParseJSONFromString(data);
      }

      if (!jsonObj) {
        const rawText =
          (data && data.text) ||
          (typeof data === "string" ? data : JSON.stringify(data, null, 2));
        resultDiv.innerHTML =
          '<pre class="whitespace-pre-wrap text-xs p-3 bg-yellow-50 border border-yellow-200 rounded-lg">' +
          rawText +
          "</pre>";
        return;
      }

      // Beautiful rendering of dialogue and vocabulary
      let html = `
      <div class="space-y-4">
        <!-- Generated Time -->
        <div class="text-xs text-gray-500 text-right pb-2 border-b border-gray-200">
          ${elapsedSeconds}ì´ˆ ë§Œì— ìƒì„±ë¨
        </div>

        <!-- Dialogue Section -->
        <div>
          <div class="flex items-center gap-2 mb-3">
            <span class="text-2xl">ğŸ’¬</span>
            <h3 class="font-bold text-base text-gray-900">ëŒ€í™”ë¬¸</h3>
          </div>
          <div class="space-y-2">
    `;

      // Render dialogue with alternating colors and per-item pronunciation play
      jsonObj.dialogue.forEach((d, index) => {
        const bgColor =
          index % 2 === 0
            ? "bg-blue-50 border-blue-200"
            : "bg-purple-50 border-purple-200";
        const speakerColor =
          index % 2 === 0 ? "text-blue-700" : "text-purple-700";
        const avatarEmoji =
          d.speaker === "A" || d.speaker === "í•™ìƒ" || d.speaker === "Student"
            ? "ğŸ‘¨â€ğŸ“"
            : "ğŸ‘©â€ğŸ«";

        const pron = d.pronunciation || "";

        html += `
        <div class="p-3 ${bgColor} border rounded-lg transition-all hover:shadow-md dialogue-item" data-text='${jsEsc(
          d.text
        )}' data-pron='${jsEsc(pron)}'>
          <div class="flex items-start gap-3">
            <span class="text-2xl">${avatarEmoji}</span>
            <div class="flex-1">
              <p class="font-semibold ${speakerColor} text-sm mb-1">${
          d.speaker
        }</p>
              <p class="text-gray-900 font-medium dialogue-text">${d.text}</p>
              ${
                pron
                  ? `<div class="mt-2 flex items-center gap-2 text-gray-500 text-xs italic"><button onclick="speakText('${jsEsc(
                      d.text
                    )}')" class="text-sm px-2 py-1 bg-gray-100 rounded">ğŸ”Š</button><span class="pronunciation-text"> ${pron}</span></div>`
                  : ""
              }
            </div>
          </div>
        </div>
      `;
      });

      html += `
          </div>
        </div>

        <!-- Vocabulary Section -->
        <div>
          <div class="flex items-center gap-2 mb-3">
            <span class="text-2xl">ğŸ“š</span>
            <h3 class="font-bold text-base text-gray-900">ë‹¨ì–´ì¥</h3>
          </div>
          <div class="flex flex-wrap gap-2">
    `;

      // Render vocabulary with colorful tags
      const vocabColors = [
        "bg-pink-100 text-pink-700 border-pink-200",
        "bg-indigo-100 text-indigo-700 border-indigo-200",
        "bg-green-100 text-green-700 border-green-200",
        "bg-orange-100 text-orange-700 border-orange-200",
        "bg-purple-100 text-purple-700 border-purple-200",
        "bg-blue-100 text-blue-700 border-blue-200",
      ];

      jsonObj.vocabulary.forEach((word, index) => {
        const colorClass = vocabColors[index % vocabColors.length];
        html += `
        <span class="px-4 py-2 ${colorClass} border rounded-full text-sm font-semibold transition-all hover:scale-110 hover:shadow-md cursor-default">
          ${word}
        </span>
      `;
      });

      html += `
          </div>
        </div>

        <!-- Action Buttons -->
        <div class="flex gap-2 items-center pt-2">
          <div class="flex items-center gap-2 mr-2">
            <label for="voiceSelect" class="text-xs text-gray-600">ìŒì„± ì„ íƒ</label>
            <select id="voiceSelect" class="text-sm border border-gray-200 rounded px-2 py-1 bg-white">
              <option value="">(ëª©ì†Œë¦¬ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...)</option>
            </select>
          </div>
          <button onclick="speakDialogue()" class="flex-1 bg-gradient-to-r from-blue-500 to-indigo-600 text-white px-4 py-2 rounded-lg hover:from-blue-600 hover:to-indigo-700 transition-all text-sm font-medium flex items-center justify-center gap-2">
            <span>ğŸ”Š</span>
            ëŒ€í™” ì½ì–´ì£¼ê¸°
          </button>
          <button onclick="practiceVocab()" class="flex-1 bg-gradient-to-r from-green-500 to-emerald-600 text-white px-4 py-2 rounded-lg hover:from-green-600 hover:to-emerald-700 transition-all text-sm font-medium flex items-center justify-center gap-2">
            <span>âœï¸</span>
            ë‹¨ì–´ ì—°ìŠµí•˜ê¸°
          </button>
        </div>
      </div>
    `;

      // Normalize dialogue items: allow simple string items, ensure objects have keys
      if (Array.isArray(jsonObj.dialogue)) {
        jsonObj.dialogue = jsonObj.dialogue.map((item, idx) => {
          if (typeof item === "string") {
            return {
              speaker: idx % 2 === 0 ? "A" : "B",
              text: item,
              pronunciation: "",
            };
          }
          // if item is object but missing keys, fill defaults
          const speaker = item.speaker || (idx % 2 === 0 ? "A" : "B");
          const text = item.text || item.line || "";
          const pronunciation = item.pronunciation || item.pron || "";
          return { speaker, text, pronunciation };
        });
      }

      // Set targetText to the pronunciation if available, otherwise the plain text
      if (jsonObj.dialogue && jsonObj.dialogue[0]) {
        const first = jsonObj.dialogue[0];
        document.getElementById("targetText").innerText =
          first.pronunciation || first.text || "";
      }
      resultDiv.innerHTML = html;

      // Restore button state after successful generation
      updateGenerateButtonState(false);
    } catch (error) {
      if (error.name === "AbortError") {
        // Request was aborted, already handled in stopGeneration
        return;
      }

      // Handle other errors
      updateGenerateButtonState(false);
      resultDiv.innerHTML =
        '<div class="text-sm text-red-600">ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' +
        error.message +
        "</div>";
    }
  }

  // Speak a given string using Web Speech API
  function speakText(txt) {
    if (!txt) return;
    if ("speechSynthesis" in window) {
      window.speechSynthesis.cancel();
      const u = new SpeechSynthesisUtterance(txt);
      // Prefer a Korean voice when available
      u.lang = "ko-KR";
      u.rate = 0.95;
      // pick a voice that matches Korean
      const pickKoreanVoice = () => {
        const voices = window.speechSynthesis.getVoices() || [];
        for (const v of voices) {
          if (!v) continue;
          const lname = (v.lang || "").toLowerCase();
          const n = (v.name || "").toLowerCase();
          if (
            lname.startsWith("ko") ||
            n.includes("korean") ||
            n.includes("noto") ||
            n.includes("nanum")
          ) {
            return v;
          }
        }
        return null;
      };

      // If the user selected a voice, prefer it
      try {
        const selVal = (document.getElementById("voiceSelect") || {}).value;
        if (selVal) {
          const [name, lang] = selVal.split("||");
          const voices = window.speechSynthesis.getVoices() || [];
          const found = voices.find((v) => v.name === name && v.lang === lang);
          if (found) u.voice = found;
        }
      } catch (e) {
        /* ignore */
      }

      let voice = pickKoreanVoice();
      if (!u.voice && voice) {
        u.voice = voice;
      }

      window.speechSynthesis.speak(u);
    } else {
      alert("ì´ ë¸Œë¼ìš°ì €ëŠ” ìŒì„± í•©ì„±ì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
    }
  }

  // Test model
  async function testModel() {
    console.log("testModel() called");
    const prompt = document.getElementById("testPrompt").value || "ì•ˆë…•í•˜ì„¸ìš”";
    const sel = document.getElementById("modelSelect");
    const selectedOption = sel.options[sel.selectedIndex];
    const backend = selectedOption.getAttribute("data-backend");
    const model = selectedOption.value;

    console.log("Prompt:", prompt, "Backend:", backend, "Model:", model);

    const outDiv = document.getElementById("modelTestResult");
    outDiv.classList.remove("hidden");
    outDiv.innerText = "ëª¨ë¸ í˜¸ì¶œ ì¤‘...";

    const form = new FormData();
    form.append("prompt", prompt);
    if (backend) form.append("backend", backend);
    if (model) form.append("model", model);

    try {
      const res = await fetch("/api/chat/test", {
        method: "POST",
        body: form,
      });
      console.log("Response status:", res.status);
      const data = await res.json();
      console.log("Data received:", data);
      // Render response as Markdown (sanitized). If `marked` + `DOMPurify` are
      // available, use them; otherwise fall back to plain text.
      function renderMarkdownTo(el, md) {
        // Friendly header/footer with emoji to make responses more approachable
        const header = "ğŸ’¬ **AIì˜ ë‹µë³€** â€” ì¹œì ˆí•˜ê²Œ ë„ì™€ë“œë¦´ê²Œìš”!\n\n";
        const footer = "\n\n---\n\nğŸ˜Š _ê¶ê¸ˆí•œ ì ì´ ìˆìœ¼ë©´ ì´ì–´ì„œ ë¬¼ì–´ë³´ì„¸ìš”!_";
        const decorated = header + md + footer;

        // Add more emojis: decorate headings, lists, blockquotes, and code blocks
        let emojiDecorated = decorated
          // Add sparkle to headings: # -> # âœ¨
          .replace(/^(\#{1,6}\s+)/gm, "$1âœ¨ ")
          // Add a blue diamond to unordered list items
          .replace(/^(\s*[-*+]\s+)/gm, "$1ğŸ”¹ ")
          // Add a number icon to ordered lists
          .replace(/^(\s*\d+\.\s+)/gm, "$1âœ… ")
          // Add quote emoji to blockquotes
          .replace(/^>\s*/gm, "> ğŸ’¬ ")
          // Prepend an icon before fenced code blocks (emoji on its own line)
          .replace(/```(\w*)\n/gm, "ğŸ§¾\n```$1\n")
          // Inline code gets a tag emoji and a check button emoji
          .replace(/`([^`]+)`/g, "ğŸ”– âœ… `$1`");

        if (window.marked && window.DOMPurify) {
          try {
            el.innerHTML = DOMPurify.sanitize(marked.parse(emojiDecorated));
            return;
          } catch (e) {
            // fall through to plain text
          }
        }
        // basic fallback: render decorated text
        el.textContent = emojiDecorated;
      }

      if (data.parsed) {
        const rawJson = JSON.stringify(data.parsed, null, 2);
        const md = "```json\n" + rawJson + "\n```";
        renderMarkdownTo(outDiv, md);
      } else if (data.text) {
        renderMarkdownTo(outDiv, data.text);
      } else {
        renderMarkdownTo(outDiv, JSON.stringify(data, null, 2));
      }
    } catch (e) {
      outDiv.innerText = "ëª¨ë¸ í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: " + e.message;
    }
  }

  // On DOMContentLoaded, setup generate button behavior
  window.addEventListener("DOMContentLoaded", () => {
    setupGenerateButton();
    populateVoiceList();
    initializeRecordingButtons();

    // Force update after a short delay to ensure DOM is fully ready
    setTimeout(() => {
      const btn = document.getElementById("generateBtn");
      const topic = document.getElementById("topic");
      if (btn && topic && topic.value) {
        btn.disabled = false;
        btn.classList.remove("opacity-50", "cursor-not-allowed");
        btn.classList.add("hover:from-blue-600", "hover:to-indigo-700");
      }
    }, 100);
  });

  // Populate voice select and persist choice in localStorage
  function populateVoiceList() {
    const sel = document.getElementById("voiceSelect");
    if (!sel) return;
    if (!("speechSynthesis" in window)) {
      sel.innerHTML = '<option value="">ìŒì„± ì§€ì› ë¶ˆê°€</option>';
      return;
    }

    function refresh() {
      const voices = window.speechSynthesis.getVoices() || [];
      // prefer showing Korean voices first
      voices.sort((a, b) => {
        const aKo = (a.lang || "").toLowerCase().startsWith("ko");
        const bKo = (b.lang || "").toLowerCase().startsWith("ko");
        if (aKo === bKo) return (a.name || "").localeCompare(b.name || "");
        return aKo ? -1 : 1;
      });

      let current = "";
      try {
        current = localStorage.getItem("onui_voice") || "";
      } catch (e) {
        // localStorage not available, skip
      }

      sel.innerHTML = "";
      const emptyOpt = document.createElement("option");
      emptyOpt.value = "";
      emptyOpt.innerText = "(ì‹œìŠ¤í…œ ê¸°ë³¸ ìŒì„±)";
      sel.appendChild(emptyOpt);

      voices.forEach((v) => {
        const o = document.createElement("option");
        // store by name|lang to avoid duplicates
        o.value = `${v.name}||${v.lang}`;
        o.innerText = `${v.name} (${v.lang})`;
        if (o.value === current) o.selected = true;
        sel.appendChild(o);
      });
    }

    // try to refresh now and again when voices change
    refresh();
    window.speechSynthesis.onvoiceschanged = refresh;

    sel.addEventListener("change", () => {
      try {
        localStorage.setItem("onui_voice", sel.value || "");
      } catch (e) {
        // localStorage not available, skip
      }
    });
  }

  // Enable/disable the Generate button based on topic input
  function updateGenerateButton() {
    const topic = document.getElementById("topic");
    const btn = document.getElementById("generateBtn");
    if (!btn || !topic) return;
    const hasText = topic.value && topic.value.trim().length > 0;
    btn.disabled = !hasText;
    if (hasText) {
      btn.classList.remove("opacity-50", "cursor-not-allowed");
      btn.classList.add("hover:from-blue-600", "hover:to-indigo-700");
    } else {
      btn.classList.add("opacity-50", "cursor-not-allowed");
      btn.classList.remove("hover:from-blue-600", "hover:to-indigo-700");
    }
  }

  function setupGenerateButton() {
    const topic = document.getElementById("topic");
    const btn = document.getElementById("generateBtn");
    if (!topic || !btn) return;
    // initialize state
    updateGenerateButton();
    // update on input
    topic.addEventListener("input", updateGenerateButton);
  }

  // 2. Essay test functions

    stopBtn.onclick = async () => {
      try {
        mediaRecorder.stop();
        recordBtn.disabled = false;
        recordBtn.classList.remove("opacity-50", "cursor-not-allowed");
        stopBtn.disabled = true;
        stopBtn.classList.add(
          "opacity-50",
          "cursor-not-allowed",
          "bg-gray-400"
        );
        stopBtn.classList.remove(
          "bg-gradient-to-r",
          "from-gray-600",
          "to-gray-700"
        );

        mediaRecorder.onstop = async () => {
          // Stop all tracks in the media stream
          if (mediaStream) {
            mediaStream.getTracks().forEach((track) => track.stop());
            mediaStream = null;
          }

          const audioBlob = new Blob(audioChunks, { type: "audio/wav" });
          const formData = new FormData();
          formData.append("file", audioBlob, "recording.wav");
          const targetText = document.getElementById("targetText").innerText;
          formData.append("text", targetText);

          document.getElementById("pronResult").innerHTML =
            '<div class="flex items-center gap-3"><div class="animate-spin rounded-full h-5 w-5 border-b-2 border-orange-600"></div><span class="text-sm text-gray-600">SpeechPro APIë¡œ ë¶„ì„ ì¤‘ì…ë‹ˆë‹¤...</span></div>';

          try {
            const res = await fetch("/api/speechpro/evaluate", {
              method: "POST",
              body: formData,
            });
            const data = await res.json();

            if (data.error) {
              document.getElementById("pronResult").innerHTML = `
                <div class="p-3 bg-red-50 border border-red-200 rounded-lg">
                  <p class="text-red-700 font-semibold text-sm">âš ï¸ ì˜¤ë¥˜</p>
                  <p class="text-red-600 text-xs mt-1">${data.error}</p>
                  ${
                    data.details
                      ? '<p class="text-gray-600 text-xs mt-1">' +
                        data.details +
                        "</p>"
                      : ""
                  }
                </div>
              `;
            } else {
              // Show modal with SpeechPro results
              showSpeechProModal(data, targetText);

              // Also show brief result in pronResult
              const score = data.score || 0;
              document.getElementById("pronResult").innerHTML = `
                <div class="p-3 bg-green-50 border border-green-200 rounded-lg">
                  <p class="text-sm text-gray-700">âœ… ë¶„ì„ ì™„ë£Œ! ìƒì„¸ ê²°ê³¼ëŠ” ëª¨ë‹¬ì°½ì„ í™•ì¸í•˜ì„¸ìš”.</p>
                  <p class="text-lg font-bold text-green-700 mt-1">ìµœì¢… ì ìˆ˜: ${score}ì </p>
                </div>
              `;
            }
          } catch (error) {
            document.getElementById("pronResult").innerHTML = `
              <div class="p-3 bg-red-50 border border-red-200 rounded-lg">
                <p class="text-red-700 font-semibold text-sm">âš ï¸ ì˜¤ë¥˜</p>
                <p class="text-red-600 text-xs mt-1">ë°œìŒ ë¶„ì„ ì¤‘ ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.</p>
              </div>
            `;
          }
        };
      } catch (error) {
        console.error("ë…¹ìŒ ì¤‘ì§€ ì˜¤ë¥˜:", error);
        alert("ë…¹ìŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
      }
    };
  }

  // Speak a given string using Web Speech API (used by per-item buttons)
  function speakText(txt) {
    if (!txt) return;
    if ("speechSynthesis" in window) {
      window.speechSynthesis.cancel();
      const u = new SpeechSynthesisUtterance(txt);
      u.lang = "ko-KR";
      u.rate = 0.95;
      const voices = window.speechSynthesis.getVoices() || [];
      for (const v of voices) {
        if (!v) continue;
        const lname = (v.lang || "").toLowerCase();
        const n = (v.name || "").toLowerCase();
        if (
          lname.startsWith("ko") ||
          n.includes("korean") ||
          n.includes("noto") ||
          n.includes("nanum")
        ) {
          u.voice = v;
          break;
        }
      }
      // If voices not yet loaded, try again when available
      if (!u.voice) {
        window.speechSynthesis.onvoiceschanged = () => {
          const vs = window.speechSynthesis.getVoices() || [];
          for (const v of vs) {
            const lname = (v.lang || "").toLowerCase();
            const n = (v.name || "").toLowerCase();
            if (
              lname.startsWith("ko") ||
              n.includes("korean") ||
              n.includes("noto") ||
              n.includes("nanum")
            ) {
              u.voice = v;
              break;
            }
          }
          window.speechSynthesis.speak(u);
        };
      } else {
        window.speechSynthesis.speak(u);
      }
    } else {
      alert("ì´ ë¸Œë¼ìš°ì €ëŠ” ìŒì„± í•©ì„±ì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
    }
  }

  // Speak the whole dialogue sequence; prefers pronunciation if present
  function speakDialogue() {
    const items = document.querySelectorAll("#contentResult .dialogue-item");
    if (!items.length) return;

    if ("speechSynthesis" in window) {
      window.speechSynthesis.cancel();
      items.forEach((item, index) => {
        // Prefer reading the original Korean text (Hangul). If not available,
        // fall back to the romanized pronunciation.
        const textAttr =
          item.getAttribute("data-text") ||
          item.querySelector(".dialogue-text")?.textContent ||
          "";
        const pron = item.getAttribute("data-pron");
        const txt = textAttr && textAttr.trim() ? textAttr : pron || "";
        const u = new SpeechSynthesisUtterance(txt);
        u.lang = "ko-KR";
        u.rate = 0.95;
        // If the user selected a specific voice, prefer that one
        try {
          const selVal = (document.getElementById("voiceSelect") || {}).value;
          if (selVal) {
            const [name, lang] = selVal.split("||");
            const voices = window.speechSynthesis.getVoices() || [];
            const found = voices.find(
              (v) => v.name === name && v.lang === lang
            );
            if (found) u.voice = found;
          }
        } catch (e) {}

        const voices = window.speechSynthesis.getVoices() || [];
        for (const v of voices) {
          if (!v) continue;
          const lname = (v.lang || "").toLowerCase();
          const n = (v.name || "").toLowerCase();
          if (
            lname.startsWith("ko") ||
            n.includes("korean") ||
            n.includes("noto") ||
            n.includes("nanum")
          ) {
            if (!u.voice) u.voice = v;
            break;
          }
        }
        setTimeout(() => {
          window.speechSynthesis.speak(u);
        }, index * 1800);
      });
    } else {
      alert("ì£„ì†¡í•©ë‹ˆë‹¤. ì´ ë¸Œë¼ìš°ì €ëŠ” ìŒì„± í•©ì„±ì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
    }
  }

  // Helper: Practice vocabulary (copy to pronunciation section)
  function practiceVocab() {
    const vocabElements = document.querySelectorAll(
      "#contentResult .rounded-full"
    );
    if (!vocabElements.length) return;

    const words = Array.from(vocabElements).map((el) => el.textContent.trim());
    const randomWord = words[Math.floor(Math.random() * words.length)];

    document.getElementById("targetText").innerText = randomWord;

    // Scroll to pronunciation section
    document
      .querySelector(".from-red-50")
      .scrollIntoView({ behavior: "smooth", block: "center" });

    // Visual feedback
    const targetEl = document.getElementById("targetText");
    targetEl.classList.add("animate-pulse");
    setTimeout(() => {
      targetEl.classList.remove("animate-pulse");
    }, 1000);
  }

  // 3. Fluency test
  async function checkFluency() {
    const text = document.getElementById("fluencyInput").value;
    const resultDiv = document.getElementById("fluencyResult");
    resultDiv.classList.remove("hidden");
    resultDiv.innerHTML =
      '<div class="flex items-center gap-3"><div class="animate-spin rounded-full h-5 w-5 border-b-2 border-green-600"></div><span class="text-sm text-gray-600">ì±„ì  ì¤‘...</span></div>';

    const formData = new FormData();
    formData.append("user_text", text);

    const res = await fetch("/api/fluency-check", {
      method: "POST",
      body: formData,
    });
    const json = await res.json();

    if (json.error) {
      resultDiv.innerHTML = `
        <div class="p-3 bg-red-50 border border-red-200 rounded-lg">
          <p class="text-red-700 font-semibold text-sm">âš ï¸ ì˜¤ë¥˜</p>
          <p class="text-red-600 text-xs mt-1">${json.error}</p>
        </div>
      `;
    } else {
      const score = json.score || 0;
      const scoreColor = score > 80 ? "green" : score > 60 ? "yellow" : "red";
      resultDiv.innerHTML = `
        <div class="space-y-2">
          <div class="p-3 bg-${scoreColor}-50 border border-${scoreColor}-200 rounded-lg">
            <p class="text-xs text-gray-600 mb-1">ì ìˆ˜:</p>
            <p class="text-2xl font-bold text-${scoreColor}-700">${score}ì </p>
          </div>
          ${
            json.corrected
              ? '<div class="p-3 bg-green-50 border border-green-200 rounded-lg"><p class="text-xs text-gray-600 mb-1">êµì •ëœ ë¬¸ì¥:</p><p class="text-sm text-green-700 font-medium">' +
                json.corrected +
                "</p></div>"
              : ""
          }
          ${
            json.feedback
              ? '<div class="p-3 bg-gray-50 border border-gray-200 rounded-lg"><p class="text-xs text-gray-600 mb-1">í”¼ë“œë°±:</p><p class="text-sm text-gray-900">' +
                json.feedback +
                "</p></div>"
              : ""
          }
        </div>
      `;
    }
  }

  // 4. Situational Content Generation
  async function generateSituationalContent() {
    const situation = document.getElementById("situation").value;
    const level = document.getElementById("situationLevel").value;
    const resultDiv = document.getElementById("situationalResult");

    if (!situation) {
      alert("ìƒí™©ì„ ì„ íƒí•´ì£¼ì„¸ìš”.");
      return;
    }

    resultDiv.classList.remove("hidden");
    resultDiv.innerHTML =
      '<div class="flex items-center gap-3"><div class="animate-spin rounded-full h-5 w-5 border-b-2 border-purple-600"></div><span class="text-sm text-gray-600">ì»¨í…ì¸  ìƒì„± ì¤‘...</span></div>';

    const formData = new FormData();
    formData.append("situation", situation);
    formData.append("level", level);
    formData.append("model", document.getElementById("modelSelect").value || "llama2");

    try {
      const res = await fetch("/api/situational-content", {
        method: "POST",
        body: formData,
      });
      const data = await res.json();

      if (data.error) {
        resultDiv.innerHTML = `
          <div class="p-3 bg-red-50 border border-red-200 rounded-lg">
            <p class="text-red-700 font-semibold text-sm">âš ï¸ ì˜¤ë¥˜</p>
            <p class="text-red-600 text-xs mt-1">${data.error}</p>
          </div>
        `;
      } else {
        let html = '<div class="space-y-3">';

        // ìƒí™© ì„¤ëª…
        if (data.situation_description) {
          html += `
            <div class="p-3 bg-purple-50 border border-purple-200 rounded-lg">
              <p class="text-xs text-gray-600 font-semibold mb-1">ğŸ“ ìƒí™©</p>
              <p class="text-sm text-gray-900">${data.situation_description}</p>
            </div>
          `;
        }

        // ì£¼ìš” í‘œí˜„
        if (data.key_expressions && data.key_expressions.length > 0) {
          html += `
            <div class="p-3 bg-white border border-purple-200 rounded-lg">
              <p class="text-xs text-gray-600 font-semibold mb-2">ğŸ’¬ ì£¼ìš” í‘œí˜„</p>
              <div class="space-y-2">
                ${data.key_expressions.map(expr => `
                  <div class="p-2 bg-purple-50 rounded">
                    <p class="text-sm font-medium text-gray-900">${expr.korean}</p>
                    <p class="text-xs text-gray-600 italic">${expr.romanization || ''}</p>
                    <p class="text-xs text-gray-700 mt-1">ğŸ“ ${expr.meaning}</p>
                  </div>
                `).join('')}
              </div>
            </div>
          `;
        }

        // ì˜ˆì‹œ ëŒ€í™”
        if (data.example_dialogue) {
          html += `
            <div class="p-3 bg-white border border-purple-200 rounded-lg">
              <p class="text-xs text-gray-600 font-semibold mb-2">ğŸ­ ì˜ˆì‹œ ëŒ€í™”</p>
              <div class="space-y-2 text-sm">
                ${data.example_dialogue.map(turn => `
                  <div class="p-2 ${turn.role === 'A' ? 'bg-blue-50 ml-2' : 'bg-gray-50 mr-2'} rounded">
                    <p class="font-medium text-gray-900">${turn.role}: ${turn.text}</p>
                  </div>
                `).join('')}
              </div>
            </div>
          `;
        }

        // ì–´íœ˜
        if (data.vocabulary && data.vocabulary.length > 0) {
          html += `
            <div class="p-3 bg-white border border-purple-200 rounded-lg">
              <p class="text-xs text-gray-600 font-semibold mb-2">ğŸ“š ê´€ë ¨ ì–´íœ˜</p>
              <div class="flex flex-wrap gap-2">
                ${data.vocabulary.map(word => `
                  <span class="px-2 py-1 bg-purple-100 text-purple-800 rounded-full text-xs font-medium">
                    ${word}
                  </span>
                `).join('')}
              </div>
            </div>
          `;
        }

        html += '</div>';
        resultDiv.innerHTML = html;
      }
    } catch (error) {
      resultDiv.innerHTML = `
        <div class="p-3 bg-red-50 border border-red-200 rounded-lg">
          <p class="text-red-700 font-semibold text-sm">âš ï¸ ì˜¤ë¥˜</p>
          <p class="text-red-600 text-xs mt-1">ì»¨í…ì¸  ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.</p>
        </div>
      `;
    }
  }
</script>
{% endblock %}
